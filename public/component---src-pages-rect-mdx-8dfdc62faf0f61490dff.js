(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{Pgu5:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return l})),n.d(t,"default",(function(){return s}));n("rzGZ"),n("Dq+y"),n("8npG"),n("Ggvi"),n("E5k/"),n("q1tI");var r=n("7ljp"),a=n("LmON"),c=n("EYWl"),b=n("fVd4");var l={},o={_frontmatter:l},i=a.a;function s(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,r,a={},c=Object.keys(e);for(r=0;r<c.length;r++)n=c[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,["components"]);return Object(r.b)(i,Object.assign({},o,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)(c.a,{title:"Rect",description:"Measures a DOM node's bounding box in React",mdxType:"SEO"}),Object(r.b)("h1",{id:"rect"},"Rect"),Object(r.b)(b.a,{mdxType:"TOC"},Object(r.b)(b.c,{mdxType:"TOCList"},Object(r.b)(b.b,{href:"#userect",mdxType:"TOCLink"},"useRect"),Object(r.b)(b.b,{href:"#rect-1",mdxType:"TOCLink"},"Rect"))),Object(r.b)("p",null,"Measures DOM elements (aka. bounding client rect). See also ",Object(r.b)("a",Object.assign({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect"}),"Element.getBoundingClientRect()")),Object(r.b)("h2",{id:"installation"},"Installation"),Object(r.b)("p",null,"From the command line in your project directory, run ",Object(r.b)("inlineCode",{parentName:"p"},"npm install @reach/rect")," or ",Object(r.b)("inlineCode",{parentName:"p"},"yarn add @reach/rect"),". Then import the component or hook that you need:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-bash"}),"npm install @reach/rect\n# or\nyarn add @reach/rect\n")),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),'import Rect, { useRect } from "@reach/rect";\n')),Object(r.b)("h2",{id:"component-api"},"Component API"),Object(r.b)("h3",{id:"userect"},"useRect"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"function useRect<T extends HTMLElement = HTMLElement>(nodeRef: React.RefObject<T>, observe: boolean = true, onChange?: (rect: DOMRect) => void): null | DOMRect")),Object(r.b)("p",null,"Hook that observes and returns the measurements (ClientRect) of a DOM element. Pass it the ref that placed on the element to be measured."),Object(r.b)("p",null,"If ",Object(r.b)("inlineCode",{parentName:"p"},"observe")," is false, the element's rect will no longer be observed, pass it ",Object(r.b)("inlineCode",{parentName:"p"},"true")," again and it will. This is mostly used for things like popovers and animations, so you can usually observe when you need to, and stop observing when you don't."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),'// jsx-demo\nfunction Example() {\n  // your own ref\n  const ref = useRef();\n\n  // pass it in to be observered\n  const rect = useRect(ref);\n\n  return (\n    <div>\n      <pre>{JSON.stringify(rect, null, 2)}</pre>\n      <div\n        // and then place the ref\n        ref={ref}\n        contentEditable\n        style={{\n          display: "inline-block",\n          padding: 10,\n          border: "solid 1px",\n        }}\n        dangerouslySetInnerHTML={{\n          __html: "Edit this to change the size!",\n        }}\n      />\n    </div>\n  );\n}\n')),Object(r.b)("h3",{id:"rect-1"},"Rect"),Object(r.b)("p",null,"Render prop component for use in class components to observe element measurements."),Object(r.b)("h4",{id:"rect-props"},"Rect Props"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object.assign({parentName:"tr"},{align:null}),"Prop"),Object(r.b)("th",Object.assign({parentName:"tr"},{align:null}),"Type"),Object(r.b)("th",Object.assign({parentName:"tr"},{align:null}),"Required"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(r.b)("a",Object.assign({parentName:"td"},{href:"#rect-children"}),Object(r.b)("inlineCode",{parentName:"a"},"children"))),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"func")),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"true")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(r.b)("a",Object.assign({parentName:"td"},{href:"#rect-observe"}),Object(r.b)("inlineCode",{parentName:"a"},"observe"))),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"bool")),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"false")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(r.b)("a",Object.assign({parentName:"td"},{href:"#rect-onchange"}),Object(r.b)("inlineCode",{parentName:"a"},"onChange"))),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"func")),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"false")))),Object(r.b)("h5",{id:"rect-children"},"Rect children"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"children(args: { rect: DOMRect | null; ref: React.Ref<any> }): JSX.Element")),Object(r.b)("p",null,"A function that calls back to you with a ",Object(r.b)("inlineCode",{parentName:"p"},"ref")," to place on an element and the ",Object(r.b)("inlineCode",{parentName:"p"},"rect")," measurements of the dom node."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Note"),": On the first render ",Object(r.b)("inlineCode",{parentName:"p"},"rect")," will be ",Object(r.b)("inlineCode",{parentName:"p"},"null")," because we can't measure a node that has not yet been rendered. Make sure your code accounts for this."),Object(r.b)("h5",{id:"rect-observe"},"Rect observe"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"observe?: boolean")),Object(r.b)("p",null,"Tells ",Object(r.b)("inlineCode",{parentName:"p"},"Rect")," to observe the position of the node or not. While observing, the ",Object(r.b)("inlineCode",{parentName:"p"},"children")," render prop may call back very quickly (especially while scrolling) so it can be important for performance to avoid observing when you don't need to."),Object(r.b)("p",null,"This is typically used for elements that pop over other elements (like a dropdown menu), so you don't need to observe all the time, only when the popup is active."),Object(r.b)("p",null,"Pass ",Object(r.b)("inlineCode",{parentName:"p"},"true")," to observe, ",Object(r.b)("inlineCode",{parentName:"p"},"false")," to ignore."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"<Rect observe={false}>\n  {({ rect, ref }) => (\n    <div ref={ref}>\n      <div>Will not measure the element when false</div>\n      <div>\n        Edit this code and change it to <code>true</code>\n      </div>\n      <pre>{JSON.stringify(rect, null, 2)}</pre>\n    </div>\n  )}\n</Rect>\n")),Object(r.b)("h5",{id:"rect-onchange"},"Rect onChange"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"onChange?(rect: DOMRect): void")),Object(r.b)("p",null,"Calls back whenever the ",Object(r.b)("inlineCode",{parentName:"p"},"rect")," of the element changes."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"<Rect onChange={rect => console.log(rect)}/>\n  {({ rect, ref }) => (\n    <div ref={ref}/>\n  )}\n</Rect>\n")))}s.isMDXComponent=!0},fVd4:function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"c",(function(){return p})),n.d(t,"b",(function(){return d}));n("xtjI"),n("4DPX"),n("rzGZ"),n("Dq+y"),n("8npG"),n("Ggvi"),n("E5k/");var r=n("q1tI"),a=n.n(r),c=n("mh+Z");function b(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?b(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):b(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){if(null==e)return{};var n,r,a={},c=Object.keys(e);for(r=0;r<c.length;r++)n=c[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}function s(e){var t=e.children,n=e.label,r=void 0===n?"Table of Contents":n,b=i(e,["children","label"]);return a.a.createElement("nav",Object.assign({className:"toc"},b),a.a.createElement(c.a,null,a.a.createElement("h2",null,r)),t)}function p(e){var t=e.children,n=e.style,r=void 0===n?{}:n,c=i(e,["children","style"]);return a.a.createElement("ul",Object.assign({style:l({display:"block",padding:0,listStyle:"none"},r)},c),t)}function d(e){var t=e.href,n=e.children,r=i(e,["href","children"]);return a.a.createElement("li",{style:{display:"inline-block",margin:0,padding:0}},a.a.createElement("a",Object.assign({href:t},r),n))}}}]);
//# sourceMappingURL=component---src-pages-rect-mdx-8dfdc62faf0f61490dff.js.map